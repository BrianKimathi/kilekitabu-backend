"""Flex (tokenized card) payment controller."""
import datetime
import uuid
from typing import Any, Dict

from flask import request, jsonify, current_app
from firebase_admin import db

from config import Config
from controllers.cybersource_controller import require_auth


@require_auth
def flex_charge() -> Any:
    """
    Charge a card using a CyberSource transient token generated by the Flex SDK.

    Expected JSON body:
    {
        "amount": 10.0,
        "currency": "USD",
        "transientToken": "<flex-or-unified-token>",
        "billingInfo": {
            "firstName": "...",
            "lastName": "...",
            "address1": "...",
            "locality": "...",
            "administrativeArea": "...",
            "postalCode": "00100",
            "country": "KE",
            "email": "...",
            "phoneNumber": "..."
        }
    }
    """
    print("[flex_charge] ========== Flex Token Payment ==========")

    user_id = getattr(request, "user_id", None)
    if not user_id:
        print("[flex_charge] ‚ùå No user_id on request")
        return jsonify({"error": "Unauthorized"}), 401

    cybersource_client = current_app.config.get("cybersource_client")
    if not cybersource_client:
        print("[flex_charge] ‚ùå CyberSource client not configured")
        return (
            jsonify(
                {
                    "success": False,
                    "error": "Card payments are unavailable right now. Please try again later.",
                }
            ),
            503,
        )

    data: Dict[str, Any] = request.get_json(force=True) or {}
    print(f"[flex_charge] üîç Raw payload keys: {list(data.keys()) if data else 'None'}")

    amount = float(data.get("amount") or 0)
    currency = str(data.get("currency") or "USD").upper()
    transient_token = (data.get("transientToken") or "").strip()
    billing_info = data.get("billingInfo") or {}

    print(f"[flex_charge] üí∞ Amount: {amount} {currency}")
    print(
        "[flex_charge] üìç Billing: "
        f"{billing_info.get('firstName', 'N/A')} {billing_info.get('lastName', 'N/A')}, "
        f"{billing_info.get('email', 'N/A')}, {billing_info.get('phoneNumber', 'N/A')}"
    )

    if not transient_token:
        print("[flex_charge] ‚ùå Missing transientToken")
        return jsonify({"error": "transientToken is required"}), 400

    # Validate amount limits (USD cards use their own minimum)
    min_amount = 1.0 if currency == "USD" else Config.VALIDATION_RULES["min_amount"]
    max_amount = Config.VALIDATION_RULES["max_amount"]
    if amount < min_amount:
        print(f"[flex_charge] ‚ùå Amount below minimum: {amount} < {min_amount}")
        return jsonify({"error": f"Amount must be at least {min_amount}"}), 400
    if amount > max_amount:
        print(f"[flex_charge] ‚ùå Amount above maximum: {amount} > {max_amount}")
        return jsonify({"error": f"Amount must not exceed {max_amount}"}), 400

    # Convert USD to KES for cap / credit calculations
    currency_upper = currency.upper()
    amount_in_kes = amount
    if currency_upper == "USD":
        usd_to_kes_rate = getattr(Config, "USD_TO_KES_RATE", 130.0)
        amount_in_kes = amount * usd_to_kes_rate
        print(
            f"[flex_charge] üí± Currency conversion: {amount} USD = "
            f"{amount_in_kes:.2f} KES (rate={usd_to_kes_rate})"
        )

    # Monthly cap removed: allow users to pay for up to 12 months (or more) in advance.
    now = datetime.datetime.now(datetime.timezone.utc)
    month_key = now.strftime("%Y-%m")
    
    user_ref = db.reference(f"registeredUser/{user_id}")
    user_data = user_ref.get() or {}
    monthly_paid = user_data.get("monthly_paid", {}) or {}
    month_spend = float(monthly_paid.get(month_key, 0))
    
    print("[flex_charge] üìä Monthly cap disabled:")
    print(f"[flex_charge]   - Month: {month_key}")
    print(f"[flex_charge]   - Current month spend (KES): {month_spend}")
    print(
        f"[flex_charge]   - Requested: {amount} {currency_upper} "
        f"({amount_in_kes:.2f} KES)"
    )
    
    # Create a payment id / reference
    payment_id = f"FX_{user_id[:8]}_{uuid.uuid4().hex[:12]}"
    print(f"[flex_charge] üÜî Payment ID: {payment_id}")

    # Persist initial payment record
    payments_ref = db.reference(f"payments/{user_id}")
    try:
        payments_ref.child(payment_id).set(
            {
                "payment_id": payment_id,
                "user_id": user_id,
                "amount": amount,
                "currency": currency_upper,
                "payment_method": "CARD",
                "provider": "CYBERSOURCE_FLEX",
                "status": "PENDING",
                "created_at": now.isoformat(),
            }
        )
        print("[flex_charge] üíæ Payment record stored (PENDING)")
    except Exception as e:
        print(f"[flex_charge] ‚ö†Ô∏è Failed to store payment record: {e}")

    # Call CyberSource with transient token
    print("[flex_charge] üöÄ Calling CyberSource create_payment_with_transient_token")
    result = cybersource_client.create_payment_with_transient_token(
        amount=amount,
        currency=currency_upper,
        transient_token=transient_token,
        reference_code=payment_id,
        capture=True,
    )

    ok = bool(result.get("ok"))
    status_code = int(result.get("status_code") or 500)
    if not ok:
        error = result.get("error") or "Payment failed"
        print(f"[flex_charge] ‚ùå CyberSource error: {error}")
        try:
            payments_ref.child(payment_id).update(
                {
                    "status": "FAILED",
                    "cybersource_error": error,
                    "updated_at": datetime.datetime.now(
                        datetime.timezone.utc
                    ).isoformat(),
                }
            )
        except Exception as e:
            print(f"[flex_charge] ‚ö†Ô∏è Failed to update failed payment: {e}")
        return (
            jsonify(
                {
                    "success": False,
                    "payment_id": payment_id,
                    "error": error,
                }
            ),
            status_code,
        )

    resp = result.get("response") or {}
    transaction_id = resp.get("id")
    status = (resp.get("status") or "").upper()
    print(f"[flex_charge] ‚úÖ CyberSource payment ok: status={status}, id={transaction_id}")

    # Compute credits (reuse DAILY_RATE logic)
    daily_rate = float(getattr(Config, "DAILY_RATE", 5.0))
    credit_days = max(1, int(amount_in_kes / daily_rate)) if daily_rate > 0 else int(
        amount_in_kes
    )
    print(f"[flex_charge] üí∞ Credit days from amount: {credit_days}")

    # Update user credit & monthly stats
    try:
        user_data = user_ref.get() or {}
        current_credit = int(float(user_data.get("credit_balance", 0) or 0))
        monthly = user_data.get("monthly_paid", {}) or {}
        monthly[month_key] = float(monthly.get(month_key, 0) or 0) + float(amount_in_kes)

        new_credit = current_credit + credit_days
        now_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()

        user_ref.update(
            {
                "credit_balance": int(new_credit),
                "total_payments": float(
                    user_data.get("total_payments", 0) or 0
                )
                + float(amount_in_kes),
                "monthly_paid": monthly,
                "last_payment_date": now_iso,
                "updated_at": now_iso,
            }
        )
        # Keep legacy path in sync if present
        try:
            legacy_ref = db.reference(f"users/{user_id}")
            legacy_ref.update({"credit_balance": int(new_credit)})
        except Exception as e:
            print(f"[flex_charge] ‚ö†Ô∏è Failed updating legacy user credit: {e}")

        payments_ref.child(payment_id).update(
            {
                "status": "COMPLETED",
                "transaction_id": transaction_id,
                "cybersource_response": resp,
                "updated_at": now_iso,
                "credit_days": credit_days,
            }
        )
        print(
            f"[flex_charge] ‚úÖ Credit + payment updated: new_credit={new_credit}, credit_days={credit_days}"
        )
    except Exception as e:
        print(f"[flex_charge] ‚ö†Ô∏è Failed to update user credit/payment record: {e}")

    return (
        jsonify(
            {
                "success": True,
                "payment_id": payment_id,
                "transaction_id": transaction_id,
                "status": status,
                "credit_days": credit_days,
            }
        ),
        200,
    )


